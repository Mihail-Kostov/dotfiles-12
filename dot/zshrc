# zsh options {{{

# defining word endings
WORDCHARS='*?_-.[]~=&;!#$%^(){}<>'

# history config options
HISTFILE=$HOME/.zsh_history
HISTSIZE=20000
SAVEHIST=20000

setopt append_history
setopt extended_history
setopt share_history
setopt hist_verify

# I actually want to profile my command usage
# setopt hist_ignore_all_dups

# I do not care if I entered a command with a leading space
# I want it to be stored
# setopt hist_ignore_space

# dir navigation options
setopt auto_pushd
setopt pushd_ignore_dups
setopt pushd_silent
setopt auto_cd

# glob options
setopt extended_glob # allows us to use ^ to negate globs
unsetopt nomatch # but when pattern matching fails, simply use the command as is. See robbyrussell/oh-my-zsh#449

##### completions

# explaining the compinit -u hack:
  # the compinit -u hack is called for because I run the shell as a docker image
  # and mount the dotfiles repo as a volume. Compinit gets angry at me because
  # when docker mounts the volume, the permissions are wrong.
  # So when you run `exec zsh`, for exemple, compinit gets angry at you by saying:
  # "zsh compinit: insecure directories and files, run compaudit for list."
  # The -u flag tells compinit to be silent about that.
  # more info here: http://stackoverflow.com/a/19601821/4921402
# comp bootstrap
autoload -Uz compinit && compinit -u
zstyle ':completion:*' menu select

# better completion
setopt menu_complete

# case insensitive completion
zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}'

### fuzzy completion
# lifted from http://superuser.com/a/815317/555734
# 0 -- vanilla completion (abc => abc)
# 1 -- smart case completion (abc => Abc)
# 2 -- word flex completion (abc => A-big-Car)
# 3 -- full flex completion (abc => ABraCadabra)
zstyle ':completion:*' matcher-list '' \
  'm:{a-z\-}={A-Z\_}' \
  'r:[^[:alpha:]]||[[:alpha:]]=** r:|=* m:{a-z\-}={A-Z\_}' \
  'r:[[:ascii:]]||[[:ascii:]]=** r:|=* m:{a-z\-}={A-Z\_}'

# }}}
# terminal colors {{{

TC='\e['
Rst="${TC}0m"     # Reset all coloring and style
Black="${TC}30m";
Red="${TC}31m";
Green="${TC}32m";
Yellow="${TC}33m";
Blue="${TC}34m";
Purple="${TC}35m";
Cyan="${TC}36m";
White="${TC}37m";

# }}}
# load user config {{{

SHELL_USER_CONFIG_FILE="${HOME}/.options/shell-options.conf"
if [[ -e "$SHELL_USER_CONFIG_FILE" ]]; then
  . "$SHELL_USER_CONFIG_FILE"
fi

# }}}
# exports {{{

# standard configs
export LANG=en_US.UTF-8

# let the terminal define TERM to advertise capabilities
# useful in the case of Emacs M-x shell which advertises a dumb terminal
#export TERM=xterm-256color

# }}}
# various escape code fixes {{{

# home, end, delete and backspace
bindkey "^[[1~" beginning-of-line # home key
bindkey "^[[4~" end-of-line # end key
bindkey "^[[3~" delete-char # delete key
bindkey "^H" backward-delete-char # backspace key
bindkey "^?" backward-delete-char # backspace key

# Numeric Keypad fixes
uname | grep -q Darwin; rc=$?
if [[ ! $rc = 0 ]]; then
  bindkey "${terminfo[kent]}" accept-line # numeric keypad return (enter)
fi

bindkey -s "^[Op" "0"
bindkey -s "^[On" "."
bindkey -s "^[Oq" "1"
bindkey -s "^[Or" "2"
bindkey -s "^[Os" "3"
bindkey -s "^[Ot" "4"
bindkey -s "^[Ou" "5"
bindkey -s "^[Ov" "6"
bindkey -s "^[Ow" "7"
bindkey -s "^[Ox" "8"
bindkey -s "^[Oy" "9"
bindkey -s "^[Ol" "+"
bindkey -s "^[OS" "-"
bindkey -s "^[OR" "*"
bindkey -s "^[OQ" "/"

# }}}
# editing mode setup {{{
# with help from @chadhs https://github.com/syl20bnr/spacemacs/issues/7140#issuecomment-252036519

if [[ -z ${EMACS+x} ]]; then

  export EDITOR="vim"

  # no delays when switching keymaps
  export KEYTIMEOUT=5
  # bootstrap vi-mode
  bindkey -v

  autoload -Uz edit-command-line
  zle -N edit-command-line
  bindkey -M vicmd 'gs' edit-command-line

  # bindkey -M vicmd '?' history-incremental-search-backward

  # trying to live without a customized vi-mode
  # zplug "${DOTPATH}/deps/ninrod/nin-vi-mode", from:local

else
  export EDITOR="emacsclient"
  bindkey -e
  ## command specific history search
  ### emacs bindings
  bindkey "^[[A" history-beginning-search-backward
  bindkey "^[[B" history-beginning-search-forward
fi
# }}}
# plugins {{{

deps="${DOTPATH}/deps/"

plugin_paths=(ninrod/nin-alias)
plugin_paths+=(rupa/z)
plugin_paths+=(ninrod/docker-alias)
plugin_paths+=(ninrod/docker-zsh-completion)
plugin_paths+=(Tarrasch/zsh-bd)
plugin_paths+=(supercrabtree/k)
plugin_paths+=(zsh-users/zsh-completions)
plugin_paths+=(zsh-users/zsh-syntax-highlighting)

ZSH_HIGHLIGHT_HIGHLIGHTERS=(main brackets)
typeset -A ZSH_HIGHLIGHT_STYLES
ZSH_HIGHLIGHT_STYLES[alias]='fg=cyan,bold'
ZSH_HIGHLIGHT_STYLES[command]='fg=green,bold'
ZSH_HIGHLIGHT_STYLES[function]='fg=yellow,bold'
ZSH_HIGHLIGHT_STYLES[path]='fg=blue'
ZSH_HIGHLIGHT_STYLES[path_pathseparator]='fg=yellow'
ZSH_HIGHLIGHT_STYLES[path_prefix]='fg=cyan'
ZSH_HIGHLIGHT_STYLES[path_prefix_pathseparator]='fg=red'

is_plugin() {
  local base_dir=$1
  local plugin_path=$2
  local plugin_file=${plugin_path:t}
  test -f $base_dir/$plugin_path/$plugin_file.plugin.zsh || \
    test -f $base_dir/$plugin_path/_$plugin_file || \
    test -f $base_dir/$plugin_path/$plugin_file.sh
}

construct_filename() {
  local base_dir=$1
  local plugin_path=$2
  local plugin_file=${plugin_path:t}

  name1=$base_dir/$plugin_path/$plugin_file.plugin.zsh
  name2=$base_dir/$plugin_path/_$plugin_file
  name3=$base_dir/$plugin_path/$plugin_file.sh

  if test -f $name1; then
    echo $name1
    return 0
  fi

  if test -f $name2; then
    echo $name2
    return 0
  fi

  if test -f $name3; then
    echo $name3
    return 0
  fi

  test -f $name1
}

for plugin_path ($plugin_paths); do
  if is_plugin $deps $plugin_path; then
    local file=$(construct_filename $deps $plugin_path)
    source $file
  fi
done  

# colors for GNU ls (from coreutils)
eval $(dircolors ~/.lscolors)

# }}}
# prompt {{{

# char options: ❯, λ, ➜, ∴
build_prompt_char() {
  local pc=${DOT_PROMPT_CHAR:-$}
  if [[ -n ${2+x} ]]; then
    pc="$2"
  fi
  local prompt_char="%(?.%F{$1}.%F{red})${pc}%f"
  echo -n "$prompt_char"
}

# default: showing whoami@hostname without truncation
# 1: simplest with directory truncation
# 2: showing whaami@hostname and with truncation
PROMPT='%F{blue}%1~%f %F{cyan}%n%f%F{red}@%f%F{yellow}%m%f %F{magenta}#%f  '
if [[ "${SHELL_PROMPT_INFO_LEVEL}" == "1" ]]; then
  PROMPT="%F{blue}%15<...<%1~%<<%f $(build_prompt_char magenta)  "
elif [[ "${SHELL_PROMPT_INFO_LEVEL}" == "2" ]]; then
  PROMPT="%F{blue}%10<...<%1~%<<%f %F{cyan}%n%f%F{red}@%f%F{yellow}%m%f %F{magenta}#%f  "
fi

# }}}
# bootstrap commands {{{

# user git information set up
if [[ -n ${GIT_USER_NAME+x} ]]; then
  git config --global user.name $GIT_USER_NAME
  export GIT_USER_NAME
fi
if [[ -n ${GIT_USER_EMAIL+x} ]]; then
  git config --global user.email $GIT_USER_EMAIL
  export GIT_USER_EMAIL
fi

if [[ -n ${DOTPATH+x} ]]; then
  export DOTPATH
fi

# export relevant user options
if [[ -n ${DOT_TERMINAL_EMULATOR+x} ]]; then
  export DOT_TERMINAL_EMULATOR
fi

# Emacs
# Local Variables:
# mode: sh
# End:

# }}}
